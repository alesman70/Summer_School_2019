FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(year=2000:2003), quant='pippo')
# units
FLQuant(matrix(abs(rnorm(32)), nrow=4, ncol=4),
dimnames=list(age=1:4, year=2000:2003), units="kg")
# dimnames<-
dimnames(flq) <- list(year=c('2001', '2002', '2003', '2004'))
dimnames(flq)
# NOTE: dimnames are always character ...
is.character(dimnames(flq)$year)
# but number can be used and are converted
dimnames(flq) <- list(year=2001:2004)
is.character(dimnames(flq)$year)
# units<-
units(flq) <- "t"
units(flq)
# here we go
flq
# FLQuant object can be SUBSET
# Using '[' to select
# a row
flq[1,]
# some columns
flq[, 2:4]
# or with negative indices
flq[-1,]
# Note that not all indices must be provided (unlike array)
# arr <- array(rlnorm(20),dim=c(2,5,2))
# arr[1,1,1]
flq[1,,,,,]
flq[1,1,,,,]
flq[1,1,1,1,1,1]
flq[1,,,,,]
# vs.
flq[1,]
# FLQuant(rnorm(20), dim=c(2,5,1,1,2,1),
#         dimnames=list(age=1:2,year=2000:2004, area=2))
flq[1,,,,,]
#vs
flq[1,1,1,1,1,1]
flq[1,2,,,,]
# Subsetting can be done by position, e.g. the first year
flq[,1]
# or name, e.g.
flq[,"2002"]
# To select and expand along the year dimension only, window can be used
window(flq, start=2002, end=2004)
window(flq, start=2002, end=2010)
# trim
trim(flq, year=2003:2004, age=2:4)
# A fictional weight-at-age matrix
(waa <- FLQuant(matrix(seq(2, 30, length=6), nrow=6, ncol=10),
dimnames=list(age=1:6, year=2000:2009), units="kg"))
set.seed(123)
(naa <- FLQuant(apply(matrix(rlnorm(10, log(0.5), 0.2), ncol=10), 2,
function(x) exp( -1 * cumsum(rep(x, 6)))),
dimnames=list(age=1:6, year=2000:2009), units="1000"))
# gives us the total biomass-at-age
(bma <- naa * waa)
waa
naa[1,]
# FLQuant(s) must be of the same dimensions
naa[1,] * waa
# %*% OPERATIONS
# Difference in dimensions taken care of
waa[1,] %*% naa
waa[1,]
naa
# Arithmetic operations by element work with vectors too
# get the actual numbers
naa * 1000
# Be careful with R's recycling rule, as this works (row first)
naa * c(1, 100)
naa
# Arithmetic operations by element work with vectors too
# get the actual numbers
naa * 1000
naa
c(1, 100)
# Be careful with R's recycling rule, as this works (row first)
naa * c(1, 100)
naa * exp(c(1:6))
exp(c(1:6))
#naa[1,1]*exp(c(1:6))[1]
0.639557*2.718282
naa
exp(c(1:6))
#naa[1,1]*exp(c(1:6))[1]
0.639557*2.718282
# but this issues a warning why?
naa * exp(c(1:7))
exp(c(1:7))
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2:6, sum)
bma
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2:6, sum)
# or get the mean abundance at age for the last 3 years
#apply(bma[,as.character(2007:2009)], c(1,3:6), mean)
apply(bma[,as.character(2007:2009)], 1, mean)
apply(bma[,as.character(2007:2009)], 2, mean)
# ITERS
# Adding iters in dim, dimnames, or iter
(flq <- FLQuant(rlnorm(100), dim=c(10,1,1,1,1,10), quant='age'))
flq[iter=2]
flq[iter=1]
as.data.frame(flq)
(flq <- FLQuant(rlnorm(100), dimnames=list(age=1:10, iter=1:10)))
# propagate, to expand an existing object
(bmi <- propagate(bma, iter=10))
bmidf <- as.data.frame(bmi)
bmidf
bmidf[bmidf$age==1 & bmidf$year==2000,]
# iter, iter<-
# to access or modify a subset of iters, as in [,,,,,*]
iter(flq, 1)
iter(flq, 2)
iter(flq, 1:2)
# iterMeans, iterVars
# shortcuts for apply(x, 1:5, mean/var)
iterMeans(flq)
iterVars(flq)
iterMedians(flq)
# quantile
quantile(flq, probs=0.05)
quantile(flq, probs=0.5)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2:6, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 1, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2:6, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2:6, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 2, sum)
# A most useful function for arrays
# e.g. to sum over the first dimension
apply(bma, 1, sum)
bma
flq <- FLQuant(1:240, dim=c(6,10,1,4,1,1),
dimnames=list(age=1:6, year=2003:2012, season=1:4))
(fl1<- apply(flq,c(1,2),sum))
flq
fl1
flq
(fl1<- apply(flq,c(1,2),sum))
dims(flq)$max
dims(flq)
sum(flq[1,1,,1:4,])
apply(flq,c(1,2),sum)
apply(flq, 2, sum)
flq2 > 0
(fl1<- apply(flq,c(1,2),sum))
#sum(flq[1,1,,1:4,])
(fl2<-apply(flq, 2, sum))
flq2 > 0
flq2 <- FLQuant(rnorm(6000), dimnames=list(age=1:6, year=2003:2012, iter=1:100))
flq2 > 0
sum(flq2 > 0)
# Class structure
# load data from Mediterranean Hake in GSA 9-10-11
rm(list=ls())
library(FLCore)
library(ggplotFL)
setwd("~/GIT/Summer_School_2019/Day 2/Data")
load("../Data/HKE_09_10_11_EWG15_11.RData")
# Rename the Stock object to something more handy and faster to write
hke <- HKE_09_10_11_EWG15_11
hke
hke
class(hke)
slotNames(hke)
# look at the structure
str(hke)
hke
# look at the structure
str(hke)
print(hke)
hke
print(hke)
harvest(hke)
print(hke)
hke
print(hke)
# look at the structure
str(hke)
print(hke)
name(hke)[]
# Look  at the name of the stock, why is it different after we changed the object name?
# name(hke) != object name
# If you prefer change it #
name(hke)[]="hke"
name(hke)[]
# Description
desc(hke)
# Range of ages, years, plus group and fbar
range(hke)
range(hke)["max"] <- 5
range(hke)
range(hke)["max"] <- 6
range(hke)[c("minfbar","maxfbar")]
range(hke)[c("minfbar","maxfbar")] <- c(1,5)
range(hke)
range(hke)[c("minfbar","maxfbar")] <- c(1,4)
hke <- setPlusGroup(hke,5)
catch.n(hke)
hke <- setPlusGroup(hke,6)
hke
catch.n(hke)
#let's plot it'
plot(hke)
harvest(hke)
units(landings(hke)) <- units(discards(hke)) <- "t"
units(landings.n(hke)) <- units(discards.n(hke)) <- "1000"
units(landings.wt(hke)) <- units(discards.wt(hke)) <- "kg"
#let's plot it'
plot(hke)
hke
landings(hke) + discards(hke)
catch(hke)
landings(hke) + discards(hke)
landings.n(hke)[,"2006",,,,]
catch.n(hke)[,"2006",,,,]
catch.wt(hke)
# Compute catch in weight for 2006 only,
# this is the product of number of fish @ age times the mean weight of fish @ age
quantSums(catch.n(hke)[,"2006",,,,] * catch.wt(hke)[,"2006",,,,])
catch(hke)
m(hke)
mean(m(hke))
quantMeans(m(hke))
quantMeans(m(hke)[c("0","1"),,,,,,])
m.spwn(hke)
hke@m.spwn[] <- 0.5
m.spwn(hke)
# harvest e.g. fishing mortality or harvest rate, normally defined as F
harvest(hke)
xyplot(data~age,groups=year,data=harvest(hke),type=c("l","p"))
# Size of the estimated population at sea, in terms of total biomass,total numbers at age.
stock.n(hke)
stock.wt(hke)
xyplot(data~age,groups=year,data=stock.n(hke),type=c("l","p"))
# So we compute it
computeStock(hke)
# and assign it to the slot stock
stock(hke) <- computeStock(hke)
# Recruitment
rec(hke)
xyplot(data~year,data=rec(hke),type=c("l","p"))
# Spawning Stock Biomass (SSB)
# SSB = stock.n * exp(-F * F.spwn - M * M.spwn) * stock.wt * mat
# quantSums(stock.n(hke)*stock.wt(hke)*mat(hke))
ssb(hke)
# Recruitment
rec(hke)
xyplot(data~age,groups=year,data=stock.n(hke),type=c("l","p"))
# Recruitment
rec(hke)
xyplot(data~year,data=rec(hke),type=c("l","p"))
# Spawning Stock Biomass (SSB)
# SSB = stock.n * exp(-F * F.spwn - M * M.spwn) * stock.wt * mat
# quantSums(stock.n(hke)*stock.wt(hke)*mat(hke))
ssb(hke)
mat(hke)
# METHODS Fbar = mean(F between fbar ages)
fbar(hke)
# METHODS fapex = max F per year
fapex(hke)
harvest(hke)
#METHODS Z = total mortality (F+M)
z(hke)
units(m(hke))[]="m"
z(hke)
hke@catch.n[1] # first position
hke@catch.n["1"] # first age
# hke@catch.n["1",]
hke@catch.n[,"2010"]
hke@catch.n["1","2010"]
hke@catch.n[,c("2008","2010")]
hke_rev <- hke
hke_rev@catch.n[,c("2008","2010")]
hke_rev@catch.n[,c("2008","2010")] <- NA
hke_rev@catch.n
# To print cohort in time
head(as.data.frame(catch.n(hke), cohort=TRUE),10)
# Other stuff
range(hke)
smallhke <- window(hke, start = 2008, end = 2013)
smallhke
# replace using logical values
a=catch(hke)[[6]]
a
catch(hke)[[6]] <- 99
plot(catch(hke))
# plot the FLStock
plot(hke)
# or individual parts
plot(stock(hke))
plot(stock.n(hke))
# METHODS convert to data frame
# entire FlStock
temp<-as.data.frame(hke)
temp
summary(temp)
# or only some slots
head(as.data.frame(FLQuants(catch.n=catch.n(hke), stock.n=stock.n(hke))))
head(model.frame(FLQuants(CN=catch.n(hke), TB=stock(hke))))
data("ple4")
data("ple4.indices")
# If you want access to a position in indeces
ple4.indices[[1]]@catch.n[c(1,2),11]=100
ple4.indices[[2]]@catch.n[c(1,2),2]=100
ple4.indices[[3]]@catch.n[c(1,2),16]=100
ple4.indices[[3]]@catch.n[c(1,2,3),22]=100
# Change name index name
ple4.indices@names
ple4.indices@names[1]=c("MEDITS")
ple4.indices@names[1]=c("BTS-Isis-early")
ple4.indices@names[1]=c("MEDITS")
ple4.indices@names
ple4.indices@names[1]=c("BTS-Isis-early")
ple4.indices@names
# PLUS GROUP INDEX
# #Set the plus group in the index
ple4.indices[[1]] <- FLIndex(index=setPlusGroup(index(ple4.indices[[1]]), 5))
range(ple4.indices[[1]], c("startf", "endf")) <- c(0.66, 0.75)
ple4.indices[[1]]
rm(list=ls())
# Load FLCore library
library(FLCore)
# read.table and its friends
?read.table
# Read this in using read.table() with default options
(catch.n <- read.table("../Data/hke_9_10_11_catch_n.csv"))
# Read this in using read.table() with default options
(catch.n <- read.table("../Data/hke_9_10_11_catch_n.csv"))
# Looks terrible
# what just happened?
# The separator in our file is a comma , so we need to specify that (default in read.table is white space)
(catch.n <- read.table("../Data/hke_9_10_11_catch_n.csv", sep=','))
# Better but the column and row names have been included as data
# We can try to fix this using the header and row.names options
(catch.n <- read.table("../Data/hke_9_10_11_catch_n.csv", header=TRUE, sep=','))
(catch.n <- read.table("../Data/hke_9_10_11_catch_n.csv", header=TRUE, sep=',',check.names = F))
# Can use read.csv() instead - same as read.table() but different default options
(catch.n <- read.csv("../Data/hke_9_10_11_catch_n.csv",check.names=FALSE))
(catch.n <- read.csv("../Data/hke_9_10_11_catch_n.csv",header = FALSE))
# Can use read.csv() instead - same as read.table() but different default options
(catch.n <- read.csv("../Data/hke_9_10_11_catch_n.csv",check.names=FALSE))
library(data.table)
(catch.n2 <- fread("../Data/hke_9_10_11_catch_n.csv",stringsAsFactors = F))
# We have read in the data as a data.frame
class(catch.n)
# FLQuant objects accept ‘vector’, ‘array’ or ‘matrix’. We can convert the object catch.n to a matrix.
catch.n.matrix <- as.matrix(catch.n[1:7, -1])
catch.n.matrix
catch.n.matrix
catch.n.matrix
# We need to specify the dimnames
catch.n.flq <- FLQuant(catch.n.matrix, dimnames=list(age=0:6, year = 2006:2014))
catch.n.flq
(catch.n <- read.csv("../Data/hke_9_10_11_catch_n.csv", header=FALSE))
(catch.n.matrix <- as.matrix(catch.n[2:8, -1]))
(catch.n <- read.csv("../Data/hke_9_10_11_catch_n.csv", header=FALSE,skip=1)[,-1])
(catch.n.flq <- FLQuant(catch.n.matrix, dimnames=list(age=0:6, year = 2006:2014)))
#
# age,2006,2007,2008,2009,2010,2011,2012,2013,2014
# 0,0.0097962,0.0111972,0.0099485,0.0107332,0.0100794,0.0090594,0.0122723,0.0112717,0.0091963
# 1,0.1385243,0.1465506,0.1437444,0.146009,0.1336534,0.1469369,0.1404243,0.146898,0.1544967
# 2,0.522766,0.5264274,0.5163683,0.5108274,0.5129791,0.5053598,0.5024037,0.5469402,0.4646127
# 3,1.1715577,1.1825167,1.1354463,1.159358,1.1450351,1.1673509,1.137563,1.1530822,1.1471284
# 4,1.9157514,1.8273481,1.8831095,1.87599,1.916567,1.9015151,1.9288463,1.8358521,1.8486048
# 5,2.6205658,2.8217072,2.6853483,2.6349913,2.7660951,2.6874283,2.7865475,2.603386,2.6832733
# 6,3.0005651,4.9239695,3.6367794,3.713922,3.9833698,4.0459298,3.8248526,4.382772,3.8651729
#
catch.wt <- read.csv("../Data/hke_9_10_11_catch_wt.csv", header=FALSE)
catch.wt
catch.wt.matrix <- as.matrix(catch.wt[2:8, -1])
catch.wt.matrix
catch.wt.flq <- FLQuant(catch.wt.matrix, dimnames=list(age=0:6, year = 2006:2014))
catch.wt.flq
# Read Natural mortality at age (M)
m <- read.csv("../Data/hke_9_10_11_m.csv", header=FALSE)
m
m.matrix <- as.matrix(m[2:8, -1])
m.flq <- FLQuant(m.matrix, dimnames=list(age=0:6, year = 2006:2014))
m.flq
(mat.flq <- FLQuant(matrix(c(0, 0.22, 0.87, 1, 1, 1, 1), nrow=7, ncol=9), dimnames=list(age=0:6, year = 2006:2014)))
#m.spwn(0)
(m.spawn <-  FLQuant(matrix(rep(0), nrow=7, ncol=9), dimnames=list(age=0:6, year = 2006:2014)))
hke.stk <- FLStock(catch.n = catch.n.flq,
catch.wt = catch.wt.flq,
harvest.spwn = harvest.spawn,
m.spwn = m.spawn,
m = m.flq,
mat = mat.flq)
# Assemble the full FLStock for HAKE
hke.stk <- FLStock(catch.n = catch.n.flq,
catch.wt = catch.wt.flq,
harvest.spwn = m.spawn,
m.spwn = m.spawn,
m = m.flq,
mat = mat.flq)
(harvest.spawn <-  FLQuant(matrix(rep(0), nrow=7, ncol=9), dimnames=list(age=0:6, year = 2006:2014)))
# Assemble the full FLStock for HAKE
hke.stk <- FLStock(catch.n = catch.n.flq,
catch.wt = catch.wt.flq,
harvest.spwn = harvest.spawn,
m.spwn = m.spawn,
m = m.flq,
mat = mat.flq)
hke.stk
# Compute total catch
catch(hke.stk) <- computeCatch(hke.stk)
catch(hke.stk)
plot(catch(hke.stk))
plot(hke.stk)
plot(catch(hke.stk))
plot(catch(hke.stk))
plot(hke.stk)
# Add units for example on fising mortality
units(harvest(hke.stk)) <- "f"
plot(hke.stk)
#
# age,2006,2007,2008,2009,2010,2011,2012,2013,2014
# 0,1250.42,1907.19,1544.78,1890.43,813.51,639.35,907.4,1252.29,610.5
# 1,99.67,51.52,92.69,78.11,131.46,67.18,56.44,67.21,64.5
# 2,2.32,0.95,2.97,0.38,1.46,2.45,2.37,4.37,4
# 3,0.49,0.97,1.52,0.32,0.3,1.2,0.29,0.29,0.2
# 4,0.01,0.14,0.01,0.01,0.17,0.01,0.01,0.01,0.3
# 5,0.01,0.14,0.01,0.32,0.15,0.01,0.16,0.22,0.01
#
#
(catch.n_idx <- read.csv("../Data/hke_9_10_11_idx.csv", header = TRUE))
(catch.n_idx <- read.csv("../Data/hke_9_10_11_idx.csv", header = TRUE, row.names = 1))
(catch.n_idx.matrix <- as.matrix(catch.n_idx[1:6, ]))
hke.idx <- FLQuant(catch.n_idx.matrix, dimnames=list(age=0:5, year = 2006:2014))
hke.idx
hke.idx
hke.idx <- FLIndex(catch.n = hke.idx)
hke.idx <- FLIndex(catch.n = hke.idx)
hke.idx <- FLIndices(hke.idx)
hke.idx <- FLQuant(catch.n_idx.matrix, dimnames=list(age=0:5, year = 2006:2014))
hke.idx <- FLIndex(catch.n = hke.idx)
hke.idx <- FLIndices(hke.idx)
hke.idx
# plot the only filled slot, catch.n
plot(catch.n(hke.idx[[1]]))
hke.idx[[1]]
# last thing, Set the timing of the survey!
hke.idx[[1]]@range[c('startf', 'endf')] <- c(0.66,0.75)
hke.idx[[1]]
# 100	3349	9410	6130	4065	5584	6666
# 1060	7251	3585	8642	3222	1757	3699
# 516	18221	7373	3551	2284	770	1924
# 1768	7129	14342	6598	2481	2392	1659
# 259	7170	5535	10427	5235	3322	7289
# 132	6446	5929	2032	3192	3541	5889
# 88	7030	5903	4048	2195	3972	9168
# 234	3847	10135	9008	2426	2019	13362
# 0	16809	11894	10319	7392	3356	16208
#
catch.n <- readVPAFile("../Data/her-irlw/canum.txt")
# Gives you an FLQuant
catch.n
#
her <- readFLStock("../Data/her-irlw/index.txt")
#
her <- readFLStock("../Data/her-irlw/index.txt")
her
# Easy!
# But note that we have only read in the data used by the stock assessment
# This does not include the estimated harvest rates or stock abundance
harvest(her)
# So we need to load these in separately using readVPAFile
stock.n <- readVPAFile("../Data/her-irlw/n.txt")
stock.n
# set the stock.n slot of her
stock.n(her) <- stock.n
# Do it all in one step for fishing mortality
harvest(her) <- readVPAFile("../Data/her-irlw/f.txt")
# Note that the units of the harvest slot have not been set - good idea to do this
units(harvest(her)) <- "f"
plot(her)
# Also need to do some tidying up
# Some of the data is inconsistent
# Total landings = sum(numbers * weight)
apply(landings.n(her) * landings.wt(her), 2, sum)
landings(her)
# So make consistent - use the computeLandings() method
landings(her)=computeLandings(her)
# No discard information
discards.wt(her)
discards.n(her)
# Set up the discards and catches
discards.wt(her)=landings.wt(her)
discards.n(her)=0
discards.n(her)
load("../Data/HKE_09_10_11_stk.Rdata")
stk
plot(stk)
