dat$area <- rep(c("N", "S"), length=11)
dat
dat$survey <- c(TRUE, FALSE, FALSE, rep(TRUE, 5), FALSE, TRUE, TRUE)
dat
dat
# 1. Create one numeric vector of random numbers and one character vector of the same length (have a look at runif function too)
?runif
library(ggplot2); theme_set(theme_bw())
participants <- c('nikipardalou@gmail.com','sana.khemiri@instm.rnrt.tn','rafik.zarrad@gmail.com','hanem.djabou@laposte.net','reda_fahim2010@yahoo.com','ines.haouas@instm.rnrt.tn','me.benziane@gmail.com','h.gazzar2@gmail.com','selfatimohamed@gmail.com','enrico.e.armelloni@gmail.com','martina.scanu@hotmail.it','hamdi.moussa@ogr.iu.edu.tr','rachele.corti19@gmail.com','adel_gaam@yahoo.fr','ilaria.costantini@an.ismar.cnr.it','caterina.sciagura@gmail.com','marco.barra@iamc.cnr.it','Sharif.jemaa@cnrs.edu.lb','jghabayman@gmail.com','gorfanid@gmail.com','filalitahar@gmail.com','myriamlteif@hotmail.com','reno.micallef@gov.mt','federicodimaio@libero.it','andrea.pierucci@unica.it')
participants <- participants[!participants %in% c("rafik.zarrad@gmail.com", "h.gazzar2@gmail.com")]
##participants <- c('Ale Ligas','Ale Man','Ale Orio','Chato','Coilin')
which(participants == "federicodimaio@libero.it")
library(ggplot2)
participants <- c('dhaker.troudiest@laposte.net', 'akram_turky@yahoo.com',
'quattrocchifederico@gmail.com', 'andrea.pierucci@hotmail.it',
'mennad.moussa@gmail.com', 'marcokule11@gmail.com', 'kouched_wael@yahoo.fr',
'nazliktu@gmail.com', 'merve.karakus@tarimorman.gov.tr',
'ekamberi@ubt.edu.al', 'kamel_benounnas@yahoo.fr',
'hanem.djabou@laposte.net', 'aymen.haj.82@gmail.com', 'mer_zaque@yahoo.fr',
'helenaglamuzina1@gmail.com', 'miriam.gambin@gov.mt', 'derbali10@gmail.com',
'federico.cali@irbim.cnr.it', 'gabriele.boscolopalo@gmail.com',
'savasyay@gmail.com')
n <- length(participants)
drumroll <- function(nroll = 15){
for(i in 1:nroll){
df <- data.frame(x = runif(n), y = runif(n), participant = participants)
p <- ggplot(df, aes(x = x, y = y)) +
geom_text(aes(x, y, label = participant), size = 5) +
coord_cartesian(xlim = c(-0.2, 1.2)) +
theme(
axis.line=element_blank(),axis.text.x=element_blank(),                                                                               axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
print(p)
Sys.sleep(.5)
}
df2 <- df[sample(1:nrow(df), 1), ]
p1 <- p + geom_text(data = df2, aes(x, y, label = participant), size = 5, colour = "blue")
print(p1)
##system(paste0("xcowsay -t 15 ", df2$participant, " will answer!!"))
}
drumroll(nroll = 5)
drumroll(nroll = 5)
drumroll(nroll = )
drumroll(nroll = 4)
drumroll(nroll = 20)
library(ggplot2)
participants <- c('dhaker.troudiest@laposte.net', 'akram_turky@yahoo.com',
'quattrocchifederico@gmail.com', 'andrea.pierucci@hotmail.it',
'mennad.moussa@gmail.com', 'marcokule11@gmail.com', 'kouched_wael@yahoo.fr',
'nazliktu@gmail.com', 'merve.karakus@tarimorman.gov.tr',
'ekamberi@ubt.edu.al', 'kamel_benounnas@yahoo.fr',
'hanem.djabou@laposte.net', 'aymen.haj.82@gmail.com', 'mer_zaque@yahoo.fr',
'helenaglamuzina1@gmail.com', 'miriam.gambin@gov.mt', 'derbali10@gmail.com',
'federico.cali@irbim.cnr.it', 'gabriele.boscolopalo@gmail.com','giacomosardo88@gamil.com',
'savasyay@gmail.com')
n <- length(participants)
drumroll <- function(nroll = 15){
for(i in 1:nroll){
df <- data.frame(x = runif(n), y = runif(n), participant = participants)
p <- ggplot(df, aes(x = x, y = y)) +
geom_text(aes(x, y, label = participant), size = 5) +
coord_cartesian(xlim = c(-0.2, 1.2)) +
theme(
axis.line=element_blank(),axis.text.x=element_blank(),                                                                               axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
print(p)
Sys.sleep(.5)
}
df2 <- df[sample(1:nrow(df), 1), ]
p1 <- p + geom_text(data = df2, aes(x, y, label = participant), size = 5, colour = "blue")
print(p1)
##system(paste0("xcowsay -t 15 ", df2$participant, " will answer!!"))
}
drumroll(nroll = 20)
drumroll(nroll = 20)
df$val
val <- rnorm(20)
cha <- letters[1:20]
df <- data.frame(val=val, cha=cha)
cls <- df$val
df$val
cls[cls <= 5] <- 1
cls[cls > 5] <- 0
df$cls <- cls
df
df[df$cls == 1,]
val <- runif(20, 1, 8)
cha <- letters[1:20]
df <- data.frame(val=val, cha=cha)
cls <- df$val
cls[cls <= 5] <- 1
cls[cls > 5] <- 0
df$cls <- cls
df[df$cls == 1,]
df
lst <- list(data=dat, description="Some data we cooked up")
lst
lst$dat
is.data.frame(lst$dat)
is.data.frame(lst)
lst[1]
lst[2]
is(lst[1])
lst$repetition <- lst
lst
flq <- FLQuant(1:240, dim=c(6,10,1,4,1,1),
dimnames=list(age=1:6, year=2003:2012, season=1:4))
library(FLCore)
flq <- FLQuant(1:240, dim=c(6,10,1,4,1,1),
dimnames=list(age=1:6, year=2003:2012, season=1:4))
# Load the package
library(FLCore)
# Create an empty FLQuant, the 6D array used for storing (almost) all data in FLR
FLQuant()
# Let's look at a toy example
# rnorm
# dim is n ages and n years
(flq <- FLQuant(rnorm(40), dim=c(4,10), dimnames=list(age=1:4, year=1990:1999))) # rnorm mean=0 sd=1 closer according to number of values
# what if we get the dims wrong?
FLQuant(rnorm(40), dim=c(4,9), dimnames=list(age=1:4, year=1990:1999))
FLQuant(rnorm(40), dim=c(4,9)
)
# This is a 6D array
is(flq)
dim(flq)
length(dim(flq))
length(
flq))
length(
flq)
# with dimension names a.k.a. dimnames
dimnames(flq)
# with an 'units' attribute, still unset
units(flq)
# and an specific name for the first dimension
quant(flq)
quant(flq) <- "length"
quant(flq) <- "age"
quant(flq)
# A summary look at its content and dims
summary(flq)
# or a full look at the object (useful for small objects only)
flq
# look at the structure of the FLQaunt
str(flq)
# A default plot spreads across panels all dims of length > 1
plot(flq)
# (1) Nothing, i.e. missing
FLQuant()
# (2) A vector, which goes by default along the year dim
FLQuant(1:10)
# TIP: to create it with a vector along the first dim, use
FLQuant(as.matrix(1:10))
# (3) A matrix
FLQuant(matrix(1:4, nrow=4, ncol=4))
# (4) Or an array, from 2D to 6D (have a look at unit values)
FLQuant(array(1:50, dim=c(2,5,5)))
flq <- FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(age=1:4, year=2000:2003))
flq
FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(year=2000:2003), quant='length')
FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(year=2000:2003), quant='pippo')
FLQuant(matrix(abs(rnorm(32)), nrow=4, ncol=4),
dimnames=list(age=1:4, year=2000:2003), units="kg")
# dimnames<-
dimnames(flq) <- list(year=c('2001', '2002', '2003', '2004'))
dimnames(flq)
# NOTE: dimnames are always character ...
is.character(dimnames(flq)$year)
# but number can be used and are converted
dimnames(flq) <- list(year=2001:2004)
is.character(dimnames(flq)$year)
# units<-
units(flq) <- "t"
units(flq)
# here we go
flq
# a row
flq[1,]
# some columns
flq[, 2:4]
# or with negative indices
flq[-1,]
# Note that not all indices must be provided (unlike array)
arr <- array(rlnorm(20),dim(2,5,2))
# Note that not all indices must be provided (unlike array)
arr <- array(rlnorm(20),dim=(2,5,2))
# Note that not all indices must be provided (unlike array)
arr <- array(rlnorm(20),dim=c(2,5,2))
arr[1,,]
arr
arr[1,1,]
arr[1,1,1]
# Note that not all indices must be provided (unlike array)
# arr <- array(rlnorm(20),dim=c(2,5,2))
# arr[1,1,1]
flq[1,,,,,]
flq[1,1,,,,]
flq[1,1,1,1,1,1]
flq[1,,,,,]
FLQuant(matrix(rnorm(10), nrow=2, ncol=5),
dimnames=list(year=2000:2006), quant='pippo')
FLQuant(matrix(rnorm(10), nrow=2, ncol=5),
dimnames=list(year=2000:2004), quant='pippo')
FLQuant(matrix(rnorm(10), nrow=2, ncol=5),
dimnames=list(year=2000:2004), area=c(1,2),quant='pippo')
FLQuant(matrix(rnorm(10), nrow=2, ncol=5),
dimnames=list(year=2000:2004), area=2,quant='pippo')
FLQuant(rnorm(10), dim=c(2,5),
dimnames=list(year=2000:2004), area=2,quant='pippo')
FLQuant(rnorm(10), dim=c(2,5,1,1,2,1),
dimnames=list(year=2000:2004), area=2,quant='pippo')
dimnames=list(age=1:2,year=2000:2004, area=2)
FLQuant(rnorm(20), dim=c(2,5,1,1,2,1),
)
flq[1,,,,,]
#vs
flq[1,1,1,1,1,1]
# Subsetting can be done by position, e.g. the first year
flq[,1]
# or name, e.g.
flq[,"2002"]
# To select and expand along the year dimension only, window can be used
window(flq, start=2002, end=2004)
window(flq, start=2002, end=2010)
# trim
trim(flq, year=2003:2004, age=2:4)
(waa <- FLQuant(matrix(seq(2, 30, length=6), nrow=6, ncol=10),
dimnames=list(age=1:6, year=2000:2009), units="kg"))
(naa <- FLQuant(apply(matrix(rlnorm(10, log(0.5), 0.2), ncol=10), 2,
function(x) exp( -1 * cumsum(rep(x, 6)))),
dimnames=list(age=1:6, year=2000:2009), units="1000"))
matrix(rlnorm(10, log(0.5), 0.2)
)
matrix(rlnorm(10, log(0.5), 0.2), ncol=10)
rlnorm(10, log(0.5), 0.2)
avg <- (rlnorm(10, log(0.5), 0.2)
)
avg
mean(avg)
log(0.5)
avg <- (rlnorm(10, log(0.5), 0.2))
avg <- (rlnorm(10, 0.5, 0.2))
mean(avg)
(naa <- FLQuant(apply(matrix(rlnorm(10, log(0.5), 0.2), ncol=10), 2,
function(x) exp( -1 * cumsum(rep(x, 6)))),
dimnames=list(age=1:6, year=2000:2009), units="1000"))
# gives us the total biomass-at-age
(bma <- naa * waa)
# FLQuant(s) must be of the same dimensions
naa[1,] * waa
# %*% OPERATIONS
# Difference in dimensions taken care of
waa[1,] %*% naa
waa[1,]
waa
naa
# %*% OPERATIONS
# Difference in dimensions taken care of
waa[1,] %*% naa
# Be careful with R's recycling rule, as this works (row first)
naa * c(1, 100)
c(1, 100)
naa
exp(c(1:6))
naa
naa * exp(c(1:6))
(waa <- FLQuant(matrix(seq(2, 30, length=6), nrow=6, ncol=10),
dimnames=list(age=1:6, year=2000:2009), units="kg"))
set.seed(123)
(naa <- FLQuant(apply(matrix(rlnorm(10, log(0.5), 0.2), ncol=10), 2,
function(x) exp( -1 * cumsum(rep(x, 6)))),
dimnames=list(age=1:6, year=2000:2009), units="1000"))
# gives us the total biomass-at-age
(bma <- naa * waa)
naa * exp(c(1:6))
0.639557*2.718282
naa[1,1]
exp(c(1:6))[1]
# but this issues a warning why?
naa * exp(c(1:7))
bma[,as.character(2007:2009)]
c(1,3:6)
# or get the mean abundance at age for the last 3 years
apply(bma[,as.character(2007:2009)], c(1,3:6), mean)
apply(bma[,as.character(2007:2009)], 1, mean)
apply(bma[,as.character(2007:2009)], 2, mean)
(flq <- FLQuant(rlnorm(100), dim=c(10,1,1,1,1,10), quant='age'))
# propagate, to expand an existing object
(bmi <- propagate(bma, iter=10))
bmidf <- as.data.frame(bmi)
bmidf[bmidf$age==1 & bmidf$year==2000,]
# with NAs
(bmi <- propagate(bma, iter=10, fill.iter=FALSE))
# with NAs
(bmi <- propagate(bma, iter=10, fill.iter=FALSE))
# or copies of the first iter
(bmi <- propagate(bma, iter=10, fill.iter=TRUE))
# propagate, to expand an existing object
(bmi <- propagate(bma, iter=10))
# iter, iter<-
# to access or modify a subset of iters, as in [,,,,,*]
iter(flq, 1)
iter(flq, 1:2)
iter(flq, 1)
# iter, iter<-
# to access or modify a subset of iters, as in [,,,,,*]
iter(flq, 2)
(3.4+0.34)/2
iter(flq, 1:2)
rm(list=ls())
library(FLCore)
library(ggplotFL)
load("../Data/HKE_09_10_11_EWG15_11.RData")
setwd("~/GIT/Summer_School_2019/Day 2/FLStock")
load("../Data/HKE_09_10_11_EWG15_11.RData")
# Rename the Stock object to something more handy and faster to write
hke <- HKE_09_10_11_EWG15_11
hke
class(hke)
slotNames(hke)
hke@range
# look at the structure
str(hke)
str(hke)
#let's plot it'
plot(hke)
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c("0","1"),,,,,,])
m(hke)[c(0,1),,,,,,]
m(hke)
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
m(hke)
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
exp(-1.16598)
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
quantMeans(m(hke)[c(0,1),,,,,,]) wrong!!!
exp(-m(hke)["0",,,,,,])
setwd("~/GIT/Summer_School_2019/Day 1")
#  Surplus Production in Continuous-Time (SPICT)
library(spict)
ane <- read.csv("ANE_06_nonAge.csv")
ane6 <- vector("list")
# Import Catch data (Landings plus Discards)
ane6$obsC  <- ane$catch  #catch observations
ane6$timeC <- ane$year   # time of catch observations
ane6$obsC <- c(ane6$obsC, 17830.4) # adding an extra value to update the stock
ane6$timeC <- c(ane6$timeC, 2016)  # adding an extra value to update the year
# TUNING INDEXES
# Pick surveys index, in this case an acoustic biomass index
ane6$timeI <- ane$year[59:71] # Index 1
ane6$obsI <- ane$index[59:71]
ane6$obsI <- c(ane6$obsI, 67910.3)
ane6$timeI <- c(ane6$timeI, 2016)
# Inspect the file
ane6
# Plot your data
# x11()
plotspict.data(ane6) # Notice color coding of the month!
#Plot inital guesses on the model initial values
plotspict.ci(ane6)
#The two top plots come from plotspict.data, with the dashed horizontal line representing a guess of MSY.
#This guess comes from a linear regression between the index and the catch divided by the index (middle row,left). This regression is expected to have a negative slope. A similar plot can be made showing catch versus catch/index (middle row, right) to approximately find the optimal effort (or effort proxy). The proportional increase in the index as a function of catch (bottom row, right) should show primarily positive increases in index at low catches and vice versa. Positive increases in index at large catches could indicate model violations (Source SPICT Vignette)
# Fit base model
ane6fit <- fit.spict(ane6)
# Now what ? Check list:
#  - did it converge?
#  - how is it fitting?
# Let's have a look at the Diagnostics First
# Explore convergence
capture.output(summary(ane6fit))[1:4]
# Model converged, seems ok we can proceed with further diagnostics.
# There are various objects that are stored in the fitted object
names(ane6fit)
# Calculate residuals and main diagnostics
ane6fit_diagn <- calc.osa.resid(ane6fit)
plotspict.diagnostic(ane6fit_diagn)
# Retrospective analysis
# Diagnostics, run it by taking away the last 3 years, one at a time
ane6fit_retro <- retro(ane6fit, nretroyear = 3)
# now plot it!
plotspict.retro(ane6fit_retro)
# So the model fits well, diagnostics are good, we can have a look at the final results.
# Fit Summary
summary(ane6fit)
# x11()
plot(ane6fit)
setwd("~/GIT/Summer_School_2019/Day 2/FLStock")
# Load the package
library(FLCore)
# Create an empty FLQuant, the 6D array used for storing (almost) all data in FLR
FLQuant()
# Load the package
library(FLCore)
# Create an empty FLQuant, the 6D array used for storing (almost) all data in FLR
FLQuant()
rnorm(40)
# Let's look at a toy example
# rnorm
# dim is n ages and n years
(flq <- FLQuant(rnorm(40), dim=c(4,10), dimnames=list(age=1:4, year=1990:1999))) # rnorm mean=0 sd=1 closer according to number of values
# what if we get the dims wrong?
FLQuant(rnorm(40), dim=c(4,9), dimnames=list(age=1:4, year=1990:1999))
# This is a 6D array
is(flq)
dim(flq)
# with dimension names a.k.a. dimnames
dimnames(flq)
# with dimension names a.k.a. dimnames
dimnames(flq)
# and names of dimnames ...
names(flq)
# with an 'units' attribute, still unset
units(flq)
# and an specific name for the first dimension
quant(flq)
quant(flq) <- "length"
# and an specific name for the first dimension
quant(flq)
quant(flq) <- "age"
quant(flq)
quant(flq) <- "pippo"
# and an specific name for the first dimension
quant(flq)
quant(flq) <- "age"
# A summary look at its content and dims
summary(flq)
# or a full look at the object (useful for small objects only)
flq
# look at the structure of the FLQaunt
str(flq)
# A default plot spreads across panels all dims of length > 1
plot(flq)
# or a full look at the object (useful for small objects only)
flq
# (1) Nothing, i.e. missing
FLQuant()
# (2) A vector, which goes by default along the year dim
FLQuant(1:10)
# TIP: to create it with a vector along the first dim, use
FLQuant(as.matrix(1:10))
# (4) Or an array, from 2D to 6D (have a look at unit values)
FLQuant(array(1:50, dim=c(2,5,5)))
# dimnames
flq <- FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(age=1:4, year=2000:2003))
flq
# quant
FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(year=2000:2003), quant='length')
FLQuant(matrix(rnorm(16), nrow=4, ncol=4),
dimnames=list(year=2000:2003), quant='pippo')
FLQuant(matrix(abs(rnorm(32)), nrow=4, ncol=4),
dimnames=list(age=1:4, year=2000:2003), units="kg")
# dimnames<-
dimnames(flq) <- list(year=c('2001', '2002', '2003', '2004'))
dimnames(flq)
# NOTE: dimnames are always character ...
is.character(dimnames(flq)$year)
# but number can be used and are converted
dimnames(flq) <- list(year=2001:2004)
is.character(dimnames(flq)$year)
# units<-
units(flq) <- "t"
units(flq)
# here we go
flq
# a row
flq[1,]
# some columns
flq[, 2:4]
# or with negative indices
flq[-1,]
# Note that not all indices must be provided (unlike array)
# arr <- array(rlnorm(20),dim=c(2,5,2))
# arr[1,1,1]
flq[1,,,,,]
flq[1,1,,,,]
flq[1,1,1,1,1,1]
flq[1,1,1,1,1,1]
flq[1,1,,,,]
flq[1,1,1,1,1,1]
flq[1,,,,,]
# vs.
flq[1,]
# vs.
flq[1,]
flq[1,,,,,]
